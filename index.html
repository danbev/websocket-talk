<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Introduction to WebSockets</title>

		<meta name="description" content="Introduction to WebSockets">
		<meta name="author" content="Daniel Bevenius">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/aerogear.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>WebSocket</h1>
					<p>
						<small><a href="http://dbevenius.org">Daniel Bevenius</a> / <a href="http://twitter.com/">@dbevenius</a></small>
					</p>
				</section>

				<section>
					<h1>Why WebSockets?</h1>
					<aside class="notes">
						Let's look into how we arrived to where we are today...
					</aside>
				</section>

				<section>
					<h1>HTTP 0.9</h1>
					<h3 class="fragment">1991</h3>
					<h3 class="fragment">ASCII protocol, running over a TCP/IP link</h3>
					<h3 class="fragment">Request/Response</h3>
					<h3 class="fragment">Response limited to hypertext</h3>
					<h3 class="fragment">Connection closed</h3>
					<aside class="notes">
						HTTP/0.9 get a single hypertext document - no headers or metadata.
					</aside>
				</section>

				<section>
					<h1>HTTP 1.0</h1>
					<h3 class="fragment">1996 RFC-1945</h3>
					<h3 class="fragment">Response not limited to hypertext</h3>
					<h3 class="fragment">Headers</h3>
					<h3 class="fragment">Connection closed</h3>
					<aside class="notes">
						"informal RFC with common usages"
						The need for more advanced responses like images, content negotiation,
						content encoding, character set support, multi-part types, authorization, caching, proxy behaviors, date formats, and more.
						Requiring a new TCP connection per request imposes a significant performance penalty on HTTP 1.0 (TCP slow start etc)
						(HTTP/1.0 -> new connection for every request unless 'Connection: keep-alive' is sent. Not part of the 1.0 spec)
					</aside>
				</section>

				<section>
					<h1>HTTP 1.1</h1>
					<h3 class="fragment">RFC-2068 1997</h3>
					<h3 class="fragment">RFC-2016 1999</h3>
					<h3 class="fragment">Keep-alive</h3>
					<h3 class="fragment">Chunked transfer encoding</h3>
					<h3 class="fragment">Still half duplex</h3>
					<aside class="notes">
						Official spec in 1997 and then a number of improvements in 1999.

						Keep-alive allows us to reuse the existing TCP connection for multiple requests to the same host and deliver a much faster end-user experience
						keep-alive is the default in 1.1 but was backported to 1.0 by using 'Connection: Keep-Alive'
						Called 'persistent' connection, because the connection persists across multiple requests. 

						'Transfer-Encoding: Chunked' enables streaming from the server. Server can respond with chunks of data, where each chunk is delimited by the size
						of the chunk followed by a CRLF, the data, CRLF. The response is terminated with a last-chunk (size of zero).
						
						Introduced pipelining (but not really relavent to this disucssion)
						There is also pipelining where multiple requests can be send to the server and not have to wait for a response before sending the next request.
						The advantage is that multiple requests can be sent in one go, saving having to make multiple calls. The server must send back the responses 
						in the same order though.
						Problems:
						Depending on the order in which requests are sent, if a request requiring particularly lengthy, processing like a database query, sent relatively 
						early in the pipeline, this could actually cause a degradation in performance because all the other responses have to wait for the 
						lengthy one to finish before the others can be sent back.
					</aside>
				</section>

				<section>
					<h1>Simplex</h1>
					<p>
						<img width="460" height="276" src="img/one-way-street.jpg" alt="One way street">
					</p>
					<h3 class="fragment">TV</h3>
					<h3 class="fragment">Radio</h3>
					<aside class="notes">
						Broadcast, examples tv, radio.
					</aside>
				</section>

				<section>
					<h1>Half-Duplex</h1>
					<p>
						<img width="460" height="276" src="img/one-way-bridge.jpg" alt="One-way bridge">
					</p>
					<h3 class="fragment">Walkie-talkie</h3>
					<aside class="notes">
					Send one direction at a time. Walkie-talkie communication. 
					HTTP 1.1 is like this (unless pipelineing is used)
					</aside>
				</section>

				<section>
					<h1>Full-Duplex</h1>
					<p>
						<img width="460" height="276" src="img/two-way-bridge.jpg" alt="Two-way bridge">
					</p>
					<h3 class="fragment">Telefon</h3>
					<aside class="notes">
						Send in both directions at the same time. WebSocket
					</aside>
				</section>

				<section>
					<h1>HTTP recap</h1>
					<h3 class="fragment">Half duplex</h3>
					<h3 class="fragment">Request initiated from client</h3>
					<h3 class="fragment">Server response</h3>
					<h3 class="fragment">Has worked well</h3>
					<aside class="notes">
						* Just trying to clarify that communication is initiated by the client always!
						* This worked well for the types of apps that the web was "intended" for -> Document retreival.
						* We are no longer building web pages, we are building web applications.
						* One transfer per connection (half duplex)
						* At most 6 parallel connections to one hostname, with domain sharding 15+.
					</aside>
				</section>

				<section>
					<h1>More advanced apps</h1>
					<h3 class="fragment">chat/messaging</h3>
					<h3 class="fragment">games</h3>
					<h3 class="fragment">collaboration</h3>
					<aside class="notes">
						There are certain types of application functionality that do not fit in nicely with the request/response paradigm of the web.
						These types of applications require updates to be sent from the server side to the client.
						Notice that we are talking about bi-directional full-duplex communication. A stock ticker or news feed could use web socket but 
						it could also use plain HTTP technology like Server Sent Events (SSE).
					</aside>
				</section>

				<section>
					<h1>These apps exist today</h1>
					<h3 class="fragment">How do they work?</h3>
					<aside class="notes">
						chats/messaging and games, etc are present on the web today, so how do they work if they are restricted with the reqeust/response model of
						HTTP?
					</aside>
				</section>

				<section>
					<p>
						<img width="460" height="276" src="img//ajax-comet.jpeg" alt="Comet/Ajax">
					</p>
					<aside class="notes">
						(Asynchronous JavaScript and XML)
						With Ajax, web applications can send data to, and retrieve data from, a server asynchronously (in the background) without interfering with the display (no page reload).

						Comet is a web application model in which a long-held HTTP request allows a web server to push data to a browser, without the browser explicitly requesting it
						Is also know as Ajax Push, Reverse Ajax, Two-way-web, HTTP Streaming.
						The new term was a play on Ajax (Ajax and Comet both being household cleaners common in the USA).
					</aside>
				</section>

				<section>
					<h1>"Short" Polling</h1>
					<h3 class="fragment">Polls server using an interval</h3>
					<h3 class="fragment">Might poll unnecessarily</h3>
					<h3 class="fragment">More network trafic</h3>
					<h3 class="fragment">Server resources involved to handle each poll</h3>
					<aside class="notes">
						* Actually not part of Comet as it only regards "long" polling or streaming solutions.
						* Continous requests for data from the client to server. 
						* The server can queue up data/events which are delivered to the client when it polls.
						* Really just uses Ajax with a polling interval.
						* Can be wasteful as there might not be any data to retreive. 
							* Still HTTP trafic on the wire (headers overhead!)
							* Server resources are also involved.
					</aside>
				</section>

				<section>
					<h1>Long polling</h1>
					<h3 class="fragment">Server responds when data is available</h3>
					<h3 class="fragment">Client polls again</h3>
					<aside class="notes">
						The server holds the connection open and when it has data it will respond with
						that data and then close the connection. The client then reconnects.
					</aside>
				</section>

				<section>
					<h1>Streaming</h1>
					<h3 class="fragment">Maintains an open connection to server</h3>
					<h3 class="fragment">HTTP/1.1 chunks</h3>
					<aside class="notes">
					Server maintains a persistent connection and sends chunks of data as it becomes available.
					Still http headers overhead when sending. 
					Intermediaries might have issues. Use HTTPS
					</aside>
				</section>

				<section>
					<h1>Problems with Comet</h1>
					<h3 class="fragment">New connection to poll</h3>
					<h3 class="fragment">Header overhead</h3>
					<h3 class="fragment">Server resources for processing</h3>
					<h3 class="fragment">Latency. Data not delivered until next poll</h3>
					<aside class="notes">
						* multiple connections required.
						* Browsers allow at most 6 parallel connections to one hostname, with domain sharding 15+.
						* a full HTTP Request/Response is used being which means all of the headers.
						* More data might be available when polling but will not be available to clients until the next request(poll)
					</aside>
				</section>


				<section>
					<h1>What do we want?</h1>
					<h3 class="fragment">Full-Duplex</h3>
					<h3 class="fragment">Less overhead</h3>
					<h3 class="fragment">Should work with current infrastructure</h3>
					<aside class="notes">
					 HTTP headers can be ~800 bytes.
					</aside>
				</section>

				<section>
					<h1>Solution: WebSocket</h1>
					<h3 class="fragment">Layered on top of TCP</h3>
					<h3 class="fragment">Bidirectional full duplex</h3>
					<h3 class="fragment">Works with port 80/443</h3>
					<aside class="notes">
						It's also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade request.
						The addressing allows for multiple services on one port.
					</aside>
				</section>

				<section>
					<h1>TCPConnection</h1>
					<h3 class="fragment">2007, Ian Hickson</h3>
					<ul>
						<li class="fragment">Specifications/Drafts</li>
						<ul>
							<li class="fragment">Hixie-75, Hixie-76</li>
							<ul>
								<li class="fragment">Ian <strong>"Hixie"</strong> Hickson</li>
							</ul>
							<li class="fragment">Hybi-00, Hybi-17</li>
							<ul>
								<li class="fragment"><strong>Hy</strong>pertext <strong>bi</strong>-directional</li>
								<li class="fragment">Internet Engineering Task Force</li>
								<ul>
									<li class="fragment"><a href="https://datatracker.ietf.org/wg/hybi/">BiDirectional or Server-Initiated HTTP working group</a></li>
								</ul>
							</ul>
						</ul>
					</ul>
					<aside class="notes">
						Hixie-75 Feb 4 2010  Chrome 4 and Safari 5.0.0
						Hixie-76 May 6 2010  Firefox 4.0 (disabled), Chrome 6, Safari 5.0.1, Opera 11.00 (disabled)
						Hybi-00 is just a copy of Hixie-76
						7 Hybi-07 April 22 2011 Firefox 6.
						8 Hybi-10 July 11 2011  Firefox 7, Firefox(Android) 7, Chrome 14, 
						13 RFC-6455 IE 10, Firefox 11, Firefox(Android) 11, Chrome 16, Safari 6, Opera 12.01
						draft-ietf-hybi-thewebsocketprotocol-17 Version 13 = RFC-6455
						
						Note that the native Android browser does not support WebSockets.

						Hixie stems from the Ian "Hixie" Hicksson how came up with the TCPConnection
						"Hybi" stems from "hy_pertext bi_directional". IETF working group "BiDirectional or Server-Initiated HTTP (Active WG)".
					</aside>
				</section>

				<section>
					<h1>API and Protocol</h1>
					<h3 class="fragment">API from W3C</h3>
					<h3 class="fragment">Protocol from IETF</h3>
					<aside class="notes">
						When discussing WebSockets there is the protcol that is provided by the IETF(Internet Engineering Task Force) and 
						the WebSocket API from WC3 (World Wide Web Consortium).
					</aside>
				</section>

				<section>
					<h1>WebSocket API</h1>
					<h3 class="fragment">Simple event driven API</h3>
					<aside class="notes">
						WC3.
					</aside>
				</section>

				<section>
					<h1>WebSocket object</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
					</code></pre>
					<h3 class="fragment">ws or wss</h3>
					<h3 class="fragment">Browser creates a connection</h3>
					<h3 class="fragment">Browser sends a HTTP Upgrade request</h3>
					<h3 class="fragment">Will not block</h3>
					<aside class="notes">
						* Browser will create a connection a using HTTP Upgrade request
						* The same TCP connection that was used for the HTTP request will then be used for the WebSocket communication
						  as long as the response for the upgrade is successfully verified.
						* Can use 'ws' or 'wss'. The url to the websocket server.
					</aside>
				</section>


				<section>
					<h1>HTTP Upgrade request</h1>
					<pre><code data-trim contenteditable>
GET ws://localhost:80/app HTTP/1.1
Host: localhost:80
Origin: http://localhost
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: r/9y5eS3shxHilVx0fVBcA==
					</code></pre>
					<h3 class="fragment">Origin</h3>
					<h3 class="fragment">Upgrade</h3>
					<h3 class="fragment">Connection</h3>
					<h3 class="fragment">Sec-WebSocket-Version</h3>
					<h3 class="fragment">Sec-WebSocket-Key</h3>
					<aside class="notes">
						Origin
						Same idea as Origin for browsers and allows a server to restrict which web pages can contact the server.
						Obviously, this model does not work for other clients (non browsers) as they can simply add any origin they like.

						Upgrade 
						Is used to indicate that we want to "upgrade" to WebSockets. This is a little odd as we are not upgrading at all, infact we are going
						to be using WebSocket instead of HTTP over TCP. But the 'Upgrade' header was made for extenstion and at the time probably for upgrading to a newer HTTP 
						version or for upgrading to TLS. As it is not commonly used, TSL used a different port instead, interm. might not support it at all.

						The 'Upgrade' header is hop-by-hop, it is/should not passed through proxies. 
						By specifying 'Connection: upgrade' proxies are forced to parse this header and remove any headers listed. 'Connection' is for this connection only not 
						for the end-to-end connection.
						The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field


						Connection
						HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header 
						field(s) from the message with the same name as the connection-token.
						Some proxy servers might not understand the Connection header and not remove the headers listed. Let's say that we send an upgrade request to such a proxy server.
						Client -> proxy -> server
						* In this case the client sends the upgrade request to the proxy, expecting a websocket to be create if the upgrade is successful.
						* The proxy server creates a connection to the target server and forwards the request, including all headers (just copying them).
						* The server does not know about the proxy but just sees a upgrade request and so handles it. Responding with the correct response and will keep the socket open.
						* The proxy server handles the response from the server and "forwards" it back to the client. For the client this looks like a successful upgrade to a WebSocket.
						* When the client tries to send using the web socket, the proxy server will not know how to handle it, it will not look like a HTTP request, and 
						will most probably be dropped or an error returned and the connection closed.

						Protocol version:
						Hixie-75 Feb 4 2010  Chrome 4 and Safari 5.0.0
						Hixie-76 May 6 2010  Firefox 4.0 (disabled), Chrome 6, Safari 5.0.1, Opera 11.00 (disabled)
						Hybi-00 is just a copy of Hixie-76
						7 Hybi-07 April 22 2011 Firefox 6.
						8 Hybi-10 July 11 2011  Firefox 7, Firefox(Android) 7, Chrome 14, 
						13 RFC-6455 IE 10, Firefox 11, Firefox(Android) 11, Chrome 16, Safari 6, Opera 12.01
						Note that the native Android browser does not support WebSockets.

						Sec-WebSocket-Key.  
						Is a random 16 bytes value that is base64 encoded. And used to prevent cross protcol attacks. There is nothing stopping someone from intercepting this
						header, base64 decoding it and they would have the ran
						This is really not to prevent attacks on WebSocket servers but instead against non-WebSocket server. If this did not exist, the browser could possibly be
						tricked into opening a TCP connection (by issuing a forged upgrade request) to a non-websocket server (in this case we have to imagine that there is now
						Sec-WebSocket-Accept part of the protocol).

						Several header names are reserved by browsers for platform-level usage in the XMLHttpRequest specification and thus are off-limits for use in applications. 
						The setRequestHeader(header, value) of the XMLHttpRequest object will terminate if one of these headers are used (see link), among these are:
						* Connection
						* Host
						* Origin
						* Upgrade
						or if the start of header is a case-insensitive match for Proxy- or Sec-.
						http://www.w3.org/TR/XMLHttpRequest/#dom-xmlhttprequest-setrequestheader

						These header names include those starting with Sec-, as well as common security-critical headers like referer, host, and cookie.
						The new headers defined in RFC 6455 are all prefixed with Sec-. These prefixes are so named because the browser is opening WebSocket connections on behalf of applications, 
						but the low-level, security sensitive parameters in the handshake are off-limits to application code. This effectively locks down upgrade requests so that they can only be 
						made through APIs like the WebSocket constructor and not through general HTTP APIs like XMLHttpRequest.

					</aside>
				</section>

				<section>
					<h1>HTTP Upgrade response</h1>
					<pre><code data-trim contenteditable>
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: lluo2AIajFdtzn73RnauhvkCOvU=
					</code></pre>
					<h3 class="fragment">Sec-WebSocket-Accept?</h3>
				</section>

				<section>
					<h1>Sec-WebSocket-Accept</h1>
					<h3 class="fragment">base64(sha1(Sec-WebSocket-Key + GUID))</h3>
					<h3 class="fragment">Result is set as Sec-WebSocket-Accept</h3>
					<h3 class="fragment">How is this secure?</h3>
					<h3 class="fragment">It's not</h3>
					<aside class="notes">
						This is actually used to protect non-websocket servers from cross-protocol attacts. So what are those?
					</aside>
				</section>

				<section>
					<h1>Protocol Attack</h1>
					<h3 class="fragment">Protect non WebSocket servers</h3>
					<h3 class="fragment">Abuse of WebSocket object</h3>

					<aside class="notes">
						For example, this could be a request crafted and sent from a browser. It would have the correct handshake header
						as it would still be using the WebSocket object but the target server would not be a WebSocket server.
						Instead the target server would running a different protocol and by having the browser send this request might
						get that server to take action. But to actually send data to that server a connection would first have to be established.
						But a server that does not understand WebSocket would not respond with the correct Sec-WebSocket-Accept header and hence the
						browser will close the connection. So this is only to cover this particular issue. 
					</aside>
				</section>

				<section>
					<h1>Subprotocols</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app", "custom.protocol");
					</code></pre>
					<ul>
						<li class="fragment">Registered <a href="http://www.iana.org/assignments/websocket/websocket.xml">IANA</a></li>
						<ul>
							<li class="fragment">STOMP</li>
							<li class="fragment">SOAP</li>
						</ul>
						<li class="fragment">Custom</li>
					</ul>
					<aside class="notes">
						Simple or Streaming Text Oriented Messaging Protocol
						The connection will only be established if the server reports that it has selected one of these subprotocols.
						Internet Assigned Numbers Authority.
						The WebSocket protocol does not have any headers or metadata and if such metadata is required the client and the
						server must agree on their own subprotocol.
						Client can used ws.protocol to determine which protocol was chosen. It might have to send data in the "old" format
						for this server.
						If the server does not support any of the client protocols the onerror callback is invoked, and the connection is terminated.
					</aside>
				</section>

				<section>
					<h1>Events</h1>
					<h3 class="fragment">Open</h3>
					<h3 class="fragment">Message</h3>
					<h3 class="fragment">Error</h3>
					<h3 class="fragment">Close</h3>
					<aside class="notes">
						Event driven/async/"real-time"
						WC3.
					</aside>
				</section>

				<section>
					<h1>Open Event</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
ws.onopen = function() {
    console.log("Handshake completed. Connection open");
    console.log(ws.protocol);
    console.log(ws.extensions);
}
					</code></pre>
				</section>

				<section>
					<h1>Close Event</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
ws.onclose = function(e) {
    console.log(e.wasClean);
    console.log(e.code);
    console.log(e.reason);
}
					</code></pre>
					<aside class="notes">
					The wasClean property is a boolean indicating whether the connection was closed cleanly. The property is true if the WebSocket closed in response to a close frame from the server. 
					If the connection closes due to some other reason (for example, because underlying TCP connection closed), the wasClean property is false.
					</aside>
				</section>

				<section>
					<h1>Error Event</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
ws.onerror = function() {
    console.log("Error occurred. Reconnecting...");
}
					</code></pre>
					<aside class="notes">
					If you receive an error event, you can expect a close event to follow shortly. 
					The code and reason in the close event can sometimes tell you what caused the error. 
					The error event handler is a good place to call your reconnection logic to the server and handle the exceptions coming from the WebSocket object. 
					</aside>
				</section>

				<section>
					<h1>Message Event</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
ws.onmessage = function(e) {
    console.log(e.data);
}
					</code></pre>
					<h3 class="fragment">string</h3>
					<h3 class="fragment">binary</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>String</h1>
					<pre><code data-trim contenteditable>
if(typeof e.data === "string") {
    ...
}
					</code></pre>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Blob</h1>
					<pre><code data-trim contenteditable>
if(e.data instanceof Blob) {
    ...
}
					</code></pre>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>ArrayBuffer</h1>
					<pre><code data-trim contenteditable>
ws.binaryType = "arraybuffer";
if(e.data instanceof ArrayBuffer) {
    ...
}
					</code></pre>
					<aside class="notes">
					fixed-length binary data buffer.ArrayBufferView objects which can present the contents of the buffer in a specific format.
					</aside>
				</section>

				<section>
					<h1>Sending data</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
    ws.send("some data");
}
					</code></pre>
					<h3 class="fragment">string</h3>
					<h3 class="fragment">binary</h3>
					<aside class="notes">
					Will be sent as a TextFrame
					</aside>
				</section>

				<section>
					<h1>Sending binary data</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
    ws.send(new Blob("some data"));
}
					</code></pre>
					<aside class="notes">
					Will be sent as a BinaryFrame
					It is also possible to send/receive an ArrayBuffer
					</aside>
				</section>

				<section>
					<h1>bufferedAmount</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://localhost:80/app");
    if (sockjs.bufferedAmount === 0) {
         ws.send("some data");
    }
}
					</code></pre>
					<h3 class="fragment">Number of bytes that have been queued</h3>
					<h3 class="fragment">But not transmitted to the network yet</h3>
					<h3 class="fragment">Can be used to throttle</h3>
					<aside class="notes">
					Number of bytes queued up but not yet been transmitted to the network.
					</aside>
				</section>

				<section>
					<h1>Masking</h1>
					<h3 class="fragment">Required for client frames</h3>
					<h3 class="fragment">Obfuscate payload</h3>
					<h3 class="fragment">Target of attack is web infrastructure</h3>
					<aside class="notes">
						Masking is done to prevent cross-protocol attacks when an intermediate is in the picture. 
						For example, if there is a transparent/intercepting proxy in the communication path the first WebSocket upgrade might succeed and a WebSocket connection established. 
						But if the WebSocket client crafted a TextFrame that looks like a HTTP request this could be interpreted by the proxy as a HTTP request and acted upon. 

						Lets say that the protocol did not use masking. The initial handshake goes as planned but the intermediate does not understand the websocket protocol.
						The client thinks that it was a ws connection open (which is now does to the proxy server) but instead of sending "normal" data it sends what resembles
						a HTTP request:
						GET /sensitive-document HTTP/1.1
						Host: somehost.com

						Can cause ip hijacking, proxy poisoning.
					</aside>
				</section>

				<section>
					<h1>Example attack</h1>
					<h3 class="fragment">Client and server understand WebSocket</h3>
					<h3 class="fragment">Transparent proxy in the middle</h3>
					</code></pre>
					<aside class="notes">
					Example if masking was not used.
					</aside>
				</section>

				<section>
					<h1>Example attack cont</h1>
					<pre><code data-trim contenteditable>
var ws = new WebSocket("ws://server.com:80/app");
					</code></pre>
					<h3 class="fragment">Upgrade request succeeds (plain HTTP)</h3>
					<h3 class="fragment">Client has a connection to proxy</h3>
					<h3 class="fragment">Server is not the target of the attack</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Example attack cont</h1>
					<pre><code data-trim contenteditable>
ws.send("GET /clickcounter.html HTTP/1.1\r\nHOST: www.bad.com\r\n");
					</code></pre></p>
					<h3 class="fragment">Client crafts a HTTP request</h3>
					<h3 class="fragment">Proxy could interpret as HTTP request</h3>
					<h3 class="fragment">Proxy routes using HOST header</h3>
					<h3 class="fragment">IP-hijacking</h3>
					<h3 class="fragment">Access to internal servers</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Cache poisoning</h1>
					<pre><code data-trim contenteditable>
ws.send("GET /index.html HTTP/1.1\r\nHOST: www.good.com\r\n");
					</code></pre></p>
					<h3 class="fragment">Client crafts a HTTP request</h3>
					<h3 class="fragment">Caching proxy could interpret as HTTP request</h3>
					<h3 class="fragment">Proxy routes using ip address</h3>
					<h3 class="fragment">Server response with HTTP Expires header</h3>
					<h3 class="fragment">Proxy caches based on HOST header</h3>
					<h3 class="fragment">Request for 'http://www.good.com/index.html'</h3>
					<aside class="notes">
					* Proxy will route the reqest to our malicious server
					* Server will response with a HTTP Expires header so it will be cached
					* When someone request http://www.good.com/index.html they will get the malicious content.
					</aside>
				</section>

				<section>
					<h1>WebSocket Protocol RFC 6455</h1>
					<aside class="notes">
					So we've seen some of the client API and perhaps understand a little more about the initial handshake.
					Lets take a look at the WebSocket Protocol now.
					</aside>
				</section>

				<section>
					<h1>WebSocket Protocol</h1>
					<h3 class="fragment">Minimal framing</h3>
					<h3 class="fragment">Layer on top of TCP</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Wire format</h1>
					<pre><code data-trim> 
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+</code></pre>
					<aside class="notes">
					 The first byte contain:
					 0 = FIN 	-> is this the final fragment?
					 1 = RSV1 	-> 0 unless used by an extension
					 2 = RSV2 	-> 0 unless used by an extension
					 3 = RSV3 	-> 0 unless used by an extension
					 4 = OpCode (%x0=Continuation frame, %x1=text, %x2=binary
					 5 = OpCode %x3-7=reserved, %x8=close, %x9=ping, %xA=pong
					 6 = OpCode %xB-F=reserved
					 7 = OpCode
					 The second byte contain:
					 0 = MASK 	-> is this frame masked? Must be for clients
					 1 = Payload length
					 2 = Payload length
					 3 = Payload length
					 4 = Payload length
					 5 = Payload length
					 6 = Payload length
					 7 = Payload length
					 The third byte contain:
					 Depends on the value in Payload length. 
					 If 0-125, that is the payload length.
					 If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length.
					 If 127, the following 8 bytes interpreted as a 64-bit unsigned integer
					 Masking key: 4 bytes. 32 bit random value used with client to server masking.
					 Payload data.
					</aside>
				</section>

				<section>
					<h1>Frame example</h1>
					<pre><code data-trim contenteditable>
ws.send("testing");
					</code></pre>
					<ul>
						<li class="fragment"><span style="color:white">1</span><span style="color:blue">000</span><span style="color:green">0001</span></li>
						<ul>
							<li class="fragment"><span style="color:white">fin 1</span></li>
							<li class="fragment"><span style="color:blue">rsv1, rsv2, rsv3</span></li>
							<li class="fragment"><span style="color:green">opcode 1 (text)</span></li>
						</ul>
						<li class="fragment"><span style="color:yellow">1</span><span style="color:brown">0000111</span></li>
						<ul>
							<li class="fragment"><span style="color:yellow">mask 1</span></li>
							<li class="fragment"><span style="color:brown">lenght (7)</span></li>
						</ul>
						<li class="fragment">Next 4 bytes the mask</li>
						<li class="fragment">Payload data</li>
					</ul>
				</section>

				<section>
					<h1>Types of frames</h1>
					<h3 class="fragment">Text</h3>
					<h3 class="fragment">Binary</h3>
					<h3 class="fragment">Close</h3>
					<h3 class="fragment">Ping</h3>
					<h3 class="fragment">Pong</h3>
					<aside class="notes">
					So we've seen some of the client API and perhaps understand a little more about the initial handshake.
					Lets take a look at the WebSocket Protocol now.
					</aside>
				</section>


				<section>
				<img width="420" height="514" src="img/pingpong.png" alt="Ping/Pong"></br>
					<h3 class="fragment">Can be sent by both the server and the browser</h3>
					<h3 class="fragment">Currently not available in API</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>Extensions</h1>
					<h3 class="fragment">Extend the WebSocket protocol</h3>
					<h3 class="fragment">Can add new op codes and data fields to the frame</h3>
					<h3 class="fragment">Browser and server must support</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h1>mux</h1>
					<h3 class="fragment">Share a TCP connection</h3>
					<h3 class="fragment">Sec-WebSocket-Extensions: <a href="http://tools.ietf.org/html/draft-ietf-hybi-websocket-multiplexing-01">mux</a></h3>
					<aside class="notes">
					With this extension, one TCP connection can provide multiple virtual 

					Extensions are so named because they extend the WebSocket Protocol. Extensions can add new opcodes and data fields to the framing format. 
					You may find it more difficult to deploy a new extension than a new protocol (or “subprotocol”) because browser vendors must explicitly build in support for these extensions. 
					You’ll probably find it much easier to write a JavaScript library that implements a protocol than to wait for all browser vendors to standardize an extension and all users to update their browsers to the version supporting that extension.
					</aside>
				</section>

				<section>
					<h1>deflate-frame</h1>
					<h3 class="fragment">Sec-WebSocket-Extensions: <a href="http://tools.ietf.org/html/draft-tyoshino-hybi-websocket-perframe-deflate-06">deflate-frame</a></h3>
					<h3 class="fragment">Compresses the application data</h3>
					<aside class="notes">
					 There was a previous extentension named 'deflate-stream' which compressed the entire frame. This was later removed/deprecated.
					</aside>
				</section>

				<section>
					<h1>Proxies</h1>
					<h3 class="fragment">Might not understand WebSocket</h3>
					<h3 class="fragment">Might not handle Upgrade requests</h3>
					<h3 class="fragment">Use TLS</h3>
					<aside class="notes">
						Most proxies are not equipped to handle the 'upgraded' connection and either drop the connection because of an 'illegal' request or don't 
						forward the upgrade header and the application isn't able to process the request.
					</aside>
				</section>

				<section>
					<h1>Fallbacks/Polyfills</h1>
					<h3 class="fragment">SockJS</h3>
					<h3 class="fragment">socket.io</h3>
					<aside class="notes">
						Hopefully this project will die as WebSockets are implemented in all browsers.
						SockJS has the same API as WebSocket so it is a simple change.
					</aside>
				</section>

				<section>
					<h1>Future</h1>
				</section>

				<section>
					<h1>Multiplex WebSockets</h1>
					<h3 class="fragment">Multiple logic WebSocket connections over same physical connection</h3>
					<aside class="notes">
					  MUX multiple logical websocket connections over same connection.
					</aside>
				</section>

				<section>
					<h1>HTTP 2.0</h1>
					<h3 class="fragment">Faster handshake</h3>
					<h3 class="fragment">Google are working on multiplexing WebSocket over SPDY</h3>
					<h3 class="fragment">WebSocket and REST over same connection</h3>
					<aside class="notes">
					  Google are working on multiplexing WebSockets over SPDY. Will this added overhead to the protocol?
					</aside>
				</section>

				<section>
					<h1>HTTP 2.0 and SSE</h1>
					<h3 class="fragment">Back to pure HTTP using SSE for server push</h3>
					<h3 class="fragment">Use normal REST for sending</h3>
					<aside class="notes">
					  Perhaps with HTTP2.0 and SSE we could go back to using pure HTTP and use SSE for server push and normal REST for sending?
					</aside>
				</section>

				<section>
					<h1>Server Sent Events</h1>
					<h3 class="fragment">HTTP 1.1</h3>
					<h3 class="fragment">Client initiated</h3>
					<h3 class="fragment">Event based</h3>
					<h3 class="fragment">Native to browser (where supported)</h3>
					<h3 class="fragment">Polyfill available</h3>
					<h3 class="fragment">Alternative if only server -> client needed</h3>
					<aside class="notes">
						An option that exist today is also Server Sent Events which are native to browsers that support them and use HTTP/1.1.
						Just to make people aware that they don't have to use WebSocket if a simple solution is available.
						This allows for unidirectional communication of data/events from the server. 
						The impl/browser will take care for reconnects.
					    Might be nice if there is no need to send back to the server, like a news feed, stock ticker.	

						var source = new EventSource('/newsfeed');
						source.addEventListener('message', function(e) {
						  console.log(e.data);
						}, false);
						Server uses "Content-Type: text/event-stream".
						If the URL passed to the EventSource constructor is an absolute URL, its origin (scheme, domain, port) must match that of the calling page.
						You could have a servlet that serves 'newsfeed'. Although not in the standard yet support for CORS is coming.
					</aside>
				</section>

				<section>
					<h1>Questions?</h1>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
